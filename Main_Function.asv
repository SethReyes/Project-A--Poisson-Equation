%%Poisson Equation







% Domain of Interest: ax < x < bx, ay < y < by
ax = -pi; bx = pi;
ay = -pi; by = pi;
% Grid
N=10; step = 1/N;
xLen=2*pi; yLen=2*pi; % Square domain


x=linspace(ax,bx,N);
y=linspace(ay,by,N);
[xx,yy]=meshgrid(x,-y);
h=(bx-ax)/(N-1);

%% Boundary Conditions
U = zeros(N,N);
fb = (by-yy).^2*cos(pi.*yy/by);
gb = (by-yy).^2.*yy;
% Walls of U 
U(2:N-1,1) = fb(2:N-1,1);
U(2:N-1,N) = gb(2:N-1,N);
temp = (by-ay)^2*cos(pi*ay/by) + (xx-ax)/(bx-ax)*((by-ay)^2*ay-(by-ay)^2*cos(pi*ay/by));
U(N,2:N-1) = temp(N,2:N-1);
% Corners of U
U(N,1) = (U(N-1,1)+U(N,2))/2;
U(N,N) = (U(N,N-1)+U(N-1,N))/2;
F = zeros(N,N);
F = cos(pi/2*(2.*((xx-ax)/(bx-ax))+1)).*sin(pi.*(yy-ay)/(by-ay));

%% Gauss-Siedel Method
GSU=U;
maxError=1;
SORiterations=0;
while 1e-7 < maxError
    prevU=GSU;
    GSU(1,1) = (GSU(1,2) + GSU(2,1))/2;
    GSU(1,N) = (GSU(1,N-1)+GSU(2,N))/2;
    % Neumann Boundary Condition 2*Udown+Uleft+Uright
    GSU(1,2:N-1) = 1/4*(2*GSU(1+1,2:N-1)+GSU(1,(2:N-1)-1)+GSU(1,(2:N-1)+1)+h^2*F(1,2:N-1));
    for i=2:N-1
        for j=2:N-1  
        GSU(i,j) = (1/4)*(prevU(i+1,j)+prevU(i-1,j)+prevU(i,j+1)+prevU(i,j-1)+(h^2)*F(i,j));
        end
    end
    %Error check
    maxError=0;
    for i=1:N-1
        for j=2:N-1
            difference=abs(prevU(i,j)-GSU(i,j));
            if difference > maxError
                maxError=difference;
            end
        end
    end
    SORiterations=SORiterations+1;
end
[Uxx,Uyy]=gradient(-GSU,h,h);
tU = sqrt(Uxx.^2+Uyy.^2);

SORiterations
GSU;

% Vector field of U
figure(1)
set(gcf,'units','normalized','position',[0.2 0.5 0.3 0.32]);
mesh(xx,yy,GSU);
xlabel('x'); ylabel('y'); zlabel('U');
title('Solution for U using the Gauss-Seidel Method','fontweight','normal');
rotate3d
box on
axis tight
k =  colorbar;
k.Label.String = 'U';
%Countour of U
figure(2)
set(gcf,'units','normalized','position',[0.5 0.5 0.3 0.32]);
contourf(xx,yy,GSU,25);
xlabel('x '); ylabel('y ');
shading interp
title('Contour of U using the Gauss-Seidel Method','fontweight','normal');
box on
k =  colorbar;
k.Label.String = 'U';
axis square
box on


%% Successive Over Relaxation

SORU=U;
maxError=1;
SORiterations=0;
while 1e-7 < maxError
    prevU=SORU;
    SORU(1,1) = (SORU(1,2) + SORU(2,1))/2;
    SORU(1,N) = (SORU(1,N-1)+SORU(2,N))/2;
    % Neumann Boundary Condition 2*Udown+Uleft+Uright
    SORU(1,2:N-1) = 1/4*(2*SORU(1+1,2:N-1)+SORU(1,(2:N-1)-1)+SORU(1,(2:N-1)+1)+h^2*F(1,2:N-1));
    for i=2:N-1
        for j=2:N-1  
        SORU(i,j) = (1/4)*(prevU(i+1,j)+prevU(i-1,j)+prevU(i,j+1)+prevU(i,j-1)+(h^2)*F(i,j));
        end
    end
    %Error check
    maxError=0;
    for i=1:N-1
        for j=2:N-1
            difference=abs(prevU(i,j)-SORU(i,j));
            if difference > maxError
                maxError=difference;
            end
        end
    end
    SORiterations=SORiterations+1;
end
[Uxx,Uyy]=gradient(-SORU,h,h);
tU = sqrt(Uxx.^2+Uyy.^2);

SORiterations
SORU;

% Vector field of U
figure(3)
set(gcf,'units','normalized','position',[0.2 0.5 0.3 0.32]);
mesh(xx,yy,SORU);
xlabel('x'); ylabel('y'); zlabel('U');
title('Solution for U using the Successive Over Relaxation Method','fontweight','normal');
rotate3d
box on
axis tight
k =  colorbar;
k.Label.String = 'U';
%Countour of U
figure(4)
set(gcf,'units','normalized','position',[0.5 0.5 0.3 0.32]);
contourf(xx,yy,SORU,25);
xlabel('x '); ylabel('y ');
shading interp
title('Contour of U using the Successive Over Relaxation Method','fontweight','normal');
box on
k =  colorbar;
k.Label.String = 'U';
axis square
box on
